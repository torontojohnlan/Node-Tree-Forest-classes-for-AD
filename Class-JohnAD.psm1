#region Readme
<# 
Defines a class as a holder of a number of static methods that do AD-related common tasks
Many aspects of this class is around the fact that some DCs may be behind firewall hence
the need to hardcode particular DCs for any get-ad* cmdlets

How to call this class in main script

    import-module activedirectory
    add-type -AssemblyName Microsoft.ActiveDirectory.Management
    . C:\scripts\PowerShell\class-JohnAD.ps1

###############  [IMPORTANT] !!!!  ################ 
Before call this class
    Specify your forest name in contructor where it defines forests as private member
    Specify DCs that should be used where some DCs may behind firewall ($DCsForDomainThatBehindFirewall)
####################################################

This class does 3 things
    1. populating DC-domain mapping table
    2. populating Domain SID table
    3. provide functions that do different mapping and conversions
        3.1 SID -> DC; DN -> DC; FQDN -> DC 
        3.2  all functions listed in #3.1 exist to serve the purpose of locating a
            reachable DC in a particular domain. This is neccessary due to the fact
            that some domains are behind firewall, and not all DCs are reachable. If not
            for firewall, get-adDomainController cmdlet with discovery parameter can be used
        3.3 domain\ID -> DN; FQDN -> DN
    
    ------------------------------------------------------------------------
    !!! REQUIRES: "C:\scripts\PowerShell\sidtable.csv" at its current form
    ------------------------------------------------------------------------
    
    V1: 
        added below methods, 
            PopulateDCDetails, 
            export_DCs_CSV #that exports all DCs
            DN2DomainNETBiosName
        added new properties
            $adrootObj
            $micorpOjb
            $currentForestObj
        use an exception hashtable for domains that are behind firewall instead of hardcoding 
        in switch/case statement
#>
#endregion redame

#region demo section

# [ADext]::getDCfromDN("put your DN here")|write-host
# [ADext]::DCTable.getenumerator()

#endregion

import-module activeDirectory
add-type -AssemblyName Microsoft.ActiveDirectory.Management

class ADext{

    #region static properties
    static [hashtable] $DCTable=@{} # (domainFQDN, DC) pair
    static [hashtable] $domainSIDs=@{} # (SID, domainFQDN) pair
    static [String[]] $forests=@("johnfoo.tk") # forest list in scope
    #static [Microsoft.ActiveDirectory.Management.ADforest] $adrootObj
    #static [Microsoft.ActiveDirectory.Management.ADforest] $micorpObj
    #static [Microsoft.ActiveDirectory.Management.ADforest] $currentForestObj
    static [hashtable] $DCsForDomainThatBehindFirewall=@{ # list exceptions where not all DC is reachable
    }
    #endregion static properties

    static hidden populateDomainSIDTable(){ #populateDomainSIDTable begin
    <# 
    list all domain and their domain SIDs
    using recursive
    condition to return from recursive: 1) a domain not having any trustedDomain object, or
    2) recusive goes to a loop
    When find a new domain, using hash table add function to add the domain
    if the domain is already in hashtable, it should return

    # This script is currently reading SID table from file.  please see in function comment


    output: a hash table key on SID value on domain FQDN
    #>
        function get-DomainSIDsRecursively      { # hidden function
          [cmdletbinding()]
          Param(
            [string]$domainName,
            [int] $level
           )
               

            write-verbose "Build domain SID hash table ..."
            write-verbose ("{0}`tprocessing $domainName" -f $level)
            try {$do=get-addomain $domainName -server $domainName -ErrorAction SilentlyContinue}
            catch{
                write-host "[Warning]: $domainName,skipped" -foregroundcolor yellow
                return
                }
            if (-not [ADext]::domainSIDs.ContainsKey($do.domainSID.value)){[ADext]::domainSIDs.add($do.domainSID.value, $do.dnsroot)}
            else {return}

            [String]$searchbase=$do.systemscontainer
            $trustedDomains = get-adobject -ldapfilter "(objectclass=TrustedDomain)" -searchbase $searchbase -server $domainName
            foreach ($td in $trustedDomains){
                if([ADext]::domainSIDs.containsValue($td.name)) {continue}
                get-DomainSIDsrecursively -domainName $td.name -level ($level+1)
        
            }
        }

		<#
        # -----------------------------------------------------------
        # to speed up debugging, we can construct SID table from a pre-built file directly. Comment out this 
        # block to dynamically construct domain sid table
        # CSV file generated by below statement

        # $SIDtable.GetEnumerator()|select name,value|export-csv "C:\scripts\PowerShell\SIDtable.csv" -notype

        import-csv "C:\scripts\PowerShell\sidtable.csv" |foreach -begin {} -process {[ADext]::domainSIDs.add($_.key,$_.value)} -end {}
        return  #skips all lines blow
        # -------------------------------------------------------------
        #>
		
        $forestName=(get-addomain).forest
        get-domainSIDsRecursively -domainName $forestName -level 0 #-verbose
        return
    } #populateDomainSIDTable end
    static hidden populateDCDomainTable(){ # populate DC-Domain mapping table
        foreach ($fn in ([ADext]::forests)){
            try{$forest=get-adforest $fn -ea SilentlyContinue}
            catch{
                write-host "[FATAL] Failed to connect to AD : [ADext] get-adforest" -BackgroundColor DarkRed
                return
            }
            $domainNames=$forest.Domains
            foreach ($domainName in $domainNames){
                Write-Verbose (" {0}, `t`t`t {1}" -f $fn,$domainName)
                if ([ADext]::DCsForDomainThatBehindFirewall[$domainName]) # Get reachable DCs from exception list for domains that are behind firewall
                {
                        [ADext]::DCTable[$domainName]=[ADext]::DCsForDomainThatBehindFirewall[$domainName]
                }
                else 
                { #discover switch gurantees to return an DC available
                        write-verbose "other domains"
                        [ADext]::DCTable[$domainName]=(get-addomaincontroller -discover -domainname $domainName).HostName.value
                }
            } # enumerate domains
        }    # enumerate forests
    } # populate DC-Domain mapping table
    static hidden populateMiscInfo() { # populate misc. info
    }
    static ADext(){ #constructor
        # populating DC-domain table
        [ADext]::populateDCDomainTable()
        
        # populating domain SID table
        [ADext]::populateDomainSIDTable()
        #[ADext]::currentForestObj=get-adforest

    } #constructor ends
    static [String] DN2DC([String]$dn){  #need to correct: when DN contains only DC=, the result is incorrect
        Write-Verbose ("DN:{0}" -f $dn)
        return ([ADext]::DCTable)[(($DN -replace '^.+?,DC=','') -replace ',DC=','.')]
    }
    static [string] FQDN2DN($fqdn){ # transfer "domain.com" to "dc=domain,dc=com"
        return "DC="+( $fqdn -replace "\.",",DC=")
    }
    static [string] SID2DC([string]$SID){
        <#
            return DC for the domain that hosts the SID if this is a typical SID
            otherwise throw excpetion
            (if invald SID, or a well-known SID where domain SID is not part of it)
        #>
        $result=$null
        if (([regex]::Split($SID,"-")).count -ne 8) {throw ("SID does not have domain portion : {0}, this error is expected" -f $SID)}
            # if the "-" count is less than 8 then it's not a typical principal. Foe example a well known ID that don't have domain SID portion
        try{
            $result=[regex]::Match($SID, "(.+)(-)(.*)$").captures.groups[1].value
        }
        catch{
            throw ("Exception when extract domain SID out of : {0}" -f $SID)
        }
        finally{}
        return $result
    }
    static [string] FQDN2DC([string]$fqdn){ #given any domain name FQDN, return an active DC 
        return ([ADext]::DCTable)[$fqdn]}
    static [string] shortFormID2DC([string]$id){ # convert domain\id to DN
    # caller is responsible to check if this returns $null
        $arr=$id.Split("\")
        if ($null -eq $arr[1]) {return $null}
        $shortDomainName=$arr[0]
        #$samAccountName=$arr[1]

        foreach ($DC_domain_pair in [ADext]::DCTable.getEnumerator()){
            $domain=$DC_domain_pair.key
                            
            #$domainNetBIOSName = ([regex]::Match($domain,"(^.+?)(\.)(.*)")).captures.groups[1].value
            $domainNetBIOSName = [ADext]::FQDN2NetbiosDomainName($domain)
            if ($domainNetBIOSName -eq $shortDomainName) {
                $DC=$DC_domain_pair.value
                return $DC
            }
        }

        return $null
    }
    static [string] shortFormID2DN([string]$id){ # convert domain\id to DN
    # caller is responsible to check if this returns $null
        $DC=[ADext]::shortFormID2DC($id)
        if($null -eq $DC){return $null}
        
        $arr=$id.Split("\")
        #$shortDomainName=$arr[0]
        $samAccountName=$arr[1]
        try{$obj=get-adobject -LDAPFilter "(samAccountName=$samAccountName)" -Server $DC}catch{return $null}
        return $obj.distinguishedName
    }
    static [Microsoft.ActiveDirectory.Management.ADdomain] DN2DomainObject([string]$dn){ #given DN, returns domain object (i.e. domain itself, not the object that is represented by DN)
        $domainName = ($dn -replace ',DC=','.') -replace '^.+?\.'
        $targetDC=[ADext]::DCTable[$domainName]
        $domainObj = get-addomain $domainName -Server $targetDC
        return ($domainObj ) # return domain object
    }
    static [Microsoft.ActiveDirectory.Management.ADEntity] DN2Object([string]$dn) { # given DN, return the object itself
        $domainName = ($dn -replace ',DC=','.') -replace '^.+?\.'
        $targetDC=[ADext]::DCTable[$domainName]
        $obj = get-adobject -identity $dn  -Server $targetDC -properties *
        return ($obj) # return domain object        
    }
    static [string] FQDN2NetbiosDomainName([string]$fqdn){
        return ($fqdn -replace "\..+$","")
    }
    static [string] DN2DomainNETBiosName([string]$dn){
        return ($DN -replace '^.+?,DC=','') -replace ',.+$',''
    }
    static [string]Obj2shortFormID([Microsoft.ActiveDirectory.Management.ADEntity]$ADobj){
        $domainNetBIOSName=[ADext]::DN2DomainNETBiosName($adobj.distinguishedName)
        $samID=$ADobj.samAccountName
        return ($domainNetBIOSName + "\" + $samID)
    }
    static [string] DN2shortFormID([string]$dn){
        $domainNetBIOSName=[ADext]::DN2DomainNETBiosName($dn)
        $samID=([ADext]::DN2Object($dn)).samAccountName
        return ($domainNetBIOSName + "\" + $samID)
    }
    
    static [hashtable] PopulateDCDetails(){ 

        [hashtable] $result= @{}
        #$forest = $null
        $domainNames=$null
        foreach ($fn in ([ADext]::forests)){
            try{
                $forestObj=get-adforest $fn -ea SilentlyContinue
                $domainNames=$forestObj.Domains
            }
            catch{
                write-host "[FATAL] Failed to connect to AD : [ADext] get-adforest" -BackgroundColor DarkRed
                contiune
            }
            foreach ($domainName in $domainNames){
                Write-Verbose (" {0}, `t`t`t {1}" -f $fn,$domainName)
                $DCname=[ADext]::DCTable["$domainName"]
                $dcs =get-adDomainController -filter * -server $DCName
                foreach ($DC in $DCs){
                    $result[$DC.hostname]=$DC
                } #enumerate DCs
            } # enumerate domains
        }    # enumerate forests
        return $result
    } # populate a hastable(FQDN,DCobj)
    static export_DCs_CSV([string]$csvName){
        $DCHashTable=([ADext]::PopulateDCDetails()).GetEnumerator()
        #try{remove-item $csvName}catch{}

        '"Name","Domain","IP","OS","Site"' | out-file -FilePath $csvName

        foreach ($DCentry in $DCHashTable){
            $DCobj=$DCentry.value
            '"'+$DCobj.name+'",'+`
            '"'+$DCobj.domain+'",'+`
            '"'+$DCobj.IPv4Address+'",'+`
            '"'+$DCobj.OperatingSystem+'",'+`
            '"'+$DCobj.site + '"' `
            | out-file -FilePath $csvName -Append
        }

    }
}

